# Руководство по стилю кода

## Оглавление

1. [Параметры объектов и их использование в программном коде](#параметры-объектов-и-их-использование-в-программном-коде)
2. [OptReal и Real. В чем разница?](#optreal-и-real-в-чем-разница)
3. [Использование пробелов. Кейс с точкой и запятой](#использование-пробелов-кейс-с-точкой-и-запятой)
4. [Использование объекта lists](#использование-объекта-lists)
5. [Функции](#функции)
6. [Операторы](#операторы)
7. [Переменные](#переменные)
8. [Циклы](#циклы)
9. [Наименования](#наименования)
10. [Общие правила стилизации](#общие-правила-стилизации)
11. [Типовые ошибки](#типовые-ошибки)
12. [Библиотеки](#библиотеки)
13. [Логи](#логи)
14. [Комментарии](#комментарии)
15. [Архитектура](#архитектура)
16. [Аннотация типов](#аннотация-типов)
17. [Отличия между SP-XML Script и JavaScript](#отличия-между-sp-xml-script-и-javascript)

---

## 1. Параметры объектов и их использование в программном коде

### Использование параметров объекта

Использование параметров объекта позволяет вынести в часть настроек в
общий доступ.

Это упрощает использование созданных\\модифицированных компонентов для
пользователей, у которых есть права администратора, но нет опыта в
разработке программного кода

Например, если вы создали агент по отправке уведомлений, полезно вынести
текст формируемого уведомления либо в шаблон уведомления, который
вызывается программным кодом.

Либо в параметры агента.

**Объект CONFIG**

В шаблонах документов, агентах, выборках и удаленных действиях
использовать объект CONFIG, который мы создаем и объявляем в начале
кода. В этот объект мы складываем следующие значения:\
1. Все переменные/параметры объекта\
2. Все параметры, которые мы планируем получать и использовать из
Request.Query

## 2. OptReal и Real. В чем разница?

### Использование OptReal вместо Real

В документации WebSoft часто можно встретить несколько функций,
возвращающих одинаковый результат.

Например OptReal() и Real().

OptReal (1) == Real(1); // true

Но как выбрать нужный вариант?

Если в названии функции есть \"Opt\", это значит, что функция может либо
вернуть нужно значение (например, привести к действительному числу),
либо если переданное значение нельзя привести к нужному типу, то она
вернет undefined

OptReal(\"blabla\"); // undefined

Real(\"blabla\"); // Ошибка. Прерывание программного кода

Аналогичное правило распространяется и на другие функции с похожим
префиксом \\ суффиксиом - **Opt**Int, Array**Opt**FirstElem  и т.п.

## 3. Использование пробелов. Кейс с точкой и запятой

### Использование пробелов

var primDot = 1 ; // неправильно

var primDot = 1; // правильно

## 4. Использование объекта lists

### Использование lists вместо перечисления стандартных значений

Иногда в программном коде можно встретить вручную собранный массив:

**\[{\"id\":\"seminar\",\"name\":\"Семинар\"},{\"id\":\"training\",\"name\":\"Тренинг\"},{\"id\":\"conference\",\"name\":\"Конференция\"},{\"id\":\"examination\",\"name\":\"Экзамен\"},{\"id\":\"courses\",\"name\":\"Курсы\"},{\"id\":\"questioning\",\"name\":\"Анкетирование\"},{\"id\":\"corporate_seminar\",\"name\":\"Корпоративный
семинар\"},{\"id\":\"improvement_professional_skill\",\"name\":\"Повышение
квалификации\"},{\"id\":\"consulting_seminar\",\"name\":\"Консультационный
семинар\"},{\"id\":\"service_participants\",\"name\":\"Обслуживание
участников\"},{\"id\":\"information_consulting_services\",\"name\":\"Информационно-консультационные
услуги\"},{\"id\":\"education\",\"name\":\"Обучение\"}\]**

Вместо перечисления в коде стандартных статусов или справочников системы
без каталога объектов, рекомендуется использовать объект lists.

Аналогичный массив форм проведения мероприятий можно было вызвать сразу
из текущего справочника:

//tools.object_to_text(lists.event_forms, \'json\')

Прежде, чем вручную вписать в программный код массив значений из
стандартного справочника, убедитесь, что его нет в объекте lists

Пробелы в написании функций и управляющих конструкций

Всегда используйте пробел между оператором и скобкой, а также между
закрывающей скобкой блока условий (или аргументов в функции) и фигурной
скобкой области видимости.\
Пример:

*function doSomeThing(arg) {\
\...\
}*

*if (someVeryLongCondition()) {\
  doSomeThing();\
} else {\
  doSomeThing();\
}*

*try {\
    doSomeThing();\
} catch (err) {\
    alert(err);\
}*

Пробел между названием функции и открывающейскобкой аргументов не
ставится.

function doSomeThing () {\...

doSomething ();

## 5. Функции

### Использование уже написанных функций

Перед написанием функции для реализации функционала убедитесь в
отсутствии существующей функции в стандартных библиотеках WebSoft

 

**Параметры функции**

Параметры функции разделяются пробелами.

## 6. Операторы

**! вместо сравнения с false**

Если не требуется явное сравнение со значением false, то следует
использовать логическое отрицание в условиях.

if (isActive == false) {}

*if (!isActive) {} *

## 7. Переменные

**Использовать оператор var**

Все переменные вне циклов стоит объявлять, используя оператор var.

 

**Локальные переменные**

Локальные переменные необходимо объявлять ближе к месту использования.
Не следует объявлять переменные в начале блока, если они там не
используются.

 

**Константы**

Глобальные константы объявляются в начале файла.

## 8. Циклы

**Ограничение количества итераций цикла while**

Для избежания бесконечного цикла while на стадии разработки и
тестирования рекомендуется жестко ограничивать количество итераций
(100, 1000\...).

 

**Выход из рекурсии**

При использовании рекурсивных функций всегда контролируйте наличие
условия, которое ее останавливает, чтобы избежать бесконечных вызовов.

## 9. Наименования

**Функции**

Для наименования функций следует использовать lowerCamelCase. Название
функции обычно является глаголом. Название функции должно быть
описательным и отражать суть функции.

*function getPersonGameRating(checkLevel, currencyType) {}*

 

### Переменные и параметры функции

Для наименования переменных используется lowerCamelCase**. **Переменным
следует давать максимально описательные имена. Не используйте
однобуквенные переменные (кроме счетчика внутри цикла).

```javascript
var personID = 123;
```

### Константы

В именах констант используется CONSTANT_CASE: все буквы заглавные, слова
разделяются подчеркиваниями.

```javascript
var SECRET_NUMBER = 5;
```

 

### Общее

Не следует использовать в наименованиях аббревиатуры, которые могут быть
двусмысленными или незнакомыми стороннему читателю. Не создавайте
аббревиатуры путем исключения букв из слова. Не используйте транслит.

 

 

### Глобальные переменные

При наименовании переменных запрещается использовать названия глобальных
переменных.\
Список глобальных переменных:

-   **CurDate **- глобальная переменная, возвращает значение текущей
    даты и времени. Доступна в любом месте в WebTutor.

-   **DefaultDb **- глобальная переменная, которая содержит базу данных
    по умолчанию. Доступна в любом месте в WebTutor.

-   **LdsCurUserID** - глобальная переменная, которая содержит ID
    текущего пользователя системы. Доступна в любом месте в WebTutor.

-   **LdsIsServer **- глобальная переменная, содержащая информацию о
    работе в режиме сервера. Если имеет значение true, то программа
    работает в режиме сервера. Если false, то программа может работать в
    режиме пользовательского рабочего места (клиента). 

-   **LdsIsClient **- глобальная переменная, содержащая информацию о
    работе в режиме клиента. Если имеет значение true, то программа
    работает в режиме пользовательского рабочего места (клиента). Если
    false, то программа может работать в режиме сервера. 

-   **curUserID** - идентификатор объекта текущего пользователя

-   **curUser **- TopElem объекта текущего пользователя

-   **curObjectID **- идентификатор объекта, показанного на странице (в
    URL - &object_id=\...)

-   **curObject **- TopElem документа объекта, показанного на странице

-   **curObjectDoc **- документ объекта, показанного на странице

-   **curDocID **- идентификатор раздела портала, показанного на
    странице (в URL - &doc_id=\...)

-   **curDoc **- TopElem документа раздела, показанного на странице

-   **curMode **- значение &mode=\... в URL

-   **curAccess** - результат проверки прав доступа (true/false)
    относительно object_id и/или doc_id

-   **curDesign **- TopElem документа дизайна текущего сайта

-   **curSite** - TopElem документа текущего сайта

-   **curHost **- TopElem документа текущего хоста

-   **curLng **- код текущего языка

## 10. Общие правила стилизации

### Пробелы вместо табов

Из пробельных символов используются только пробелы. Каждый раз, когда
открывается новый блок, вложенность увеличивается на 2 пробела. Когда
блок закрывается, вложенность возвращается на предыдущий уровень. Отступ
относится и к коду, и к комментариям в блоке.

 

### Точка с запятой

Каждое выражение должно завершаться точкой с запятой.

 

### Ширина кода

Максимальная ширина кода --- 100 символов.

 

### Переносы строк и фигурные скобки

Нет переноса строки перед открывающей фигурной скобкой.\
Перенос после открывающей скобки и перед закрывающей.\
Перенос после закрывающей скобки, если эта скобка завершает блок кода
или тело функции. Уточнение: нет переноса после скобки, если за ней
идет else , catch , while , запятая, точка с запятой, закрывающая
скобка.

Пробелы в написании функций и управляющих конструкций

Всегда используйте пробел между оператором и скобкой, а также между
закрывающей скобкой блока условий (или аргументов в функции) и фигурной
скобкой области видимости.\
Пример:

*function doSomeThing(arg) {\
\...\
}*

*if (someVeryLongCondition()) {\
  doSomeThing();\
} else {\
  doSomeThing();\
}*

*try {\
    doSomeThing();\
} catch (err) {\
    alert(err);\
}*

Пробел между названием функции и открывающейскобкой аргументов не
ставится.

function doSomeThing () {\...

doSomething ();

 

 

### Строки

Строковые литералы заключаются в одинарные кавычки.

 

**Управляющие конструкции и фигурные скобки**

Всегда используйте фигурные скобки для управляющих конструкций
( if , else , for , while и т.д.).

if (someVeryLongCondition())\
  doSomething();\
\
for (let i = 0; i \< foo.length; i++) bar(foo\[i\]);

Исключение: если инструкция полностью помещается на одной строке, то
можно убрать перенос строки и фигурные скобки. Если это улучшит
читаемость кода.

*if (shortCondition()) foo();*

 

### Длинные строки

Не используется продолжение строк (обратный слэш в конце строки).

var string = \'very very very \\\
  long string\';

Вместо него используется конкатенация (+).

*var string = \'very very very \' +\
  \'long string\';*

 

### Объекты и массивы

Инициализировать объекты при помощи литерала {} , а массивы - \[\] (сли
не требуется указание длины).

 

### Висящая запятая

Следует добавлять запятую после последнего элемента массива/свойства
объекта, если есть перенос строки перед закрывающей скобкой.

*var array = \[\
  \'value\',\
  \'value2\',\
\];*

## 11. Типовые ошибки

### Повторное открытие документа

Следует избегать повторного открытия документа. Если есть возможность,
стоит использовать свойство XmlElem.OptForeignElem , XQuery запрос,
каталог-связку. Минимизировать использование open_doc, максимально
избегать использования open_doc в циклах с большим количеством итераций

### Жесткое кодирование (hard coding)

Следует избегать использования в коде конкретного жестко закодированных
значений (например, ID объекта). Вместо этого использовать параметры
(если есть) или XQuery запросы с поиском по свойству code .

 

### SQL запросы

Перед использованием SQL запросов следует уточнить у заказчика, возможно
ли использование SQL в данном проекте, не планируется ли смена СУБД.

 

**Оставленные Alert и  DropFormsCache**

Необходимо убирать отладочные Аlert \'ы и вызовы DropFormsCache перед
релизом кода.

 

### Неиспользование файлов логов

Если требуется логирование большого количества данных, стоит
использовать собственный журнал сервера.

 

**Alert в цикле**

Не следует использовать Alert \'ы внутри циклов с большим количеством
итераций. Вместо этого стоит добавлять записи в массив и выводить его
после цикла.

 

**Неоправданное использование настраиваемых полей и типов документов**

Если есть возможность использовать стандартное поле для хранения
необходимой информации, то стоит использовать его.

 

### Оптимизации кода с обращением к БД

Рекомендуется при написании кода исключать обращения к БД в циклах. В
большинстве случаев менее ресурсозатратным методом будет одно обращение
к БД вне цикла для получения массива с нужной информацией и
использование ArrayOptFind() для поиска информации в единожды полученном
массиве на каждой итерации работы цикла.\
**Пример:**

var tasks = XQuery(\'for \$elem in tasks return \$elem\');

var collaborators = XQuery(\'for \$elem in collaborators return
\$elem\');

var task, taskDoc, executor;

for (task in tasks) {

if (!task.executor_id.HasValue) continue;

executor = ArrayOptFind(collaborators, \'This.id == \' +
task.executor_id);

if (executor == undefined) continue;

taskDoc = tools.open_doc(task.id);

taskDoc.TopElem.name = executor.fullname + \': \' + task.name;

taskDoc.Save();

}

### Исключать из финальных редакций кода неиспользуемый код
(неиспользуемые функции и т.д.)

 

### Не использовать Try Catch в циклах, либо использовать только при
разработке

## 12. Библиотеки

### Выносить переиспользуемые функции

Функции, которые можно будет использовать в других объектах системы
следует выносить в библиотеку программного кода.

 

**Добавлять аннотации JSDoc для каждой функции библиотеки**

Каждая функция библиотеки должна быть задокументирована, используя
синтаксис [[JSDoc]{.underline}](https://jsdoc.app/). Это облегчит ее
использование в будущем и увеличит количество людей, которым она будет
полезна. [[Подробнее про аннотацию
типов]{.underline}](http://178.154.255.90/_wt/7330274860971794293).

 

### Разделять библиотеки по функциональным блокам

Библиотеки должны группировать функции по какому-либо признаку.
Например, \"функции для работы с массивами\" или \"функции для работы с
БД\".

 

### Функции библиотеки должны быть универсальными

При проектировании функции для библиотеки следует стараться сделать ее
максимально переиспользуемой. Например, функция может принимать другую
функцию, что позволит пользователю библиотеки встроить свою логику,
продолжая пользоваться возможностями библиотеки.

## 13. Логи

### Объединенный файл

Для агентов и других серверных объектов, в которых выполняется
программный код, объединенных по тематике, можно создать единый файл
логов. Для того чтобы различать логи из разных объектов, необходимо
добавлять уникальный префикс объекта при записи в лог.

*function log(message) {\
  LogEvent(\'adaptation\', \'\[websoft_adaptations_create\] \' +
message);\
}*

 

### Уведомления о критических логах

Следует отправлять email уведомления ответственному сотруднику с логом
при возникновении критической ошибки.

 

### Прозрачность для пользователя

Необходимо создавать логирование таким образом, чтобы пользователю было
понятно из-за чего возникла ошибка, например, \"Ошибка: Некорректно
заполнен параметр агента \'Процедура оценки\'. Убедитесь, что выбрали
актуальную процедуры оценки.\"

Если на проекте необходимо оставить включенными какое-то логгирование,
никогда не оставлять их в alert, всегда создавать отдельный лог для
LogEvent

Использовать alert только для отладки в ходе разработки. LogEvent
оставлять при сдаче проекта только по крайней необходимости.

 

### Использовать LogEvent, вместо alert

Если на проекте необходимо оставить включенными какое-то логирование,
никогда не оставлять их в alert, всегда создавать отдельный лог для
LogEvent. Использовать alert только для отладки в ходе разработки.

## 14. Комментарии

### Добавлять комментарии для неочевидных условий

Если условие относится к конкретному клиенту и является неочевидным
(например, отдельное уведомление для одного из руководителей), то стоит
добавить рядом с ним комментарий, который это пояснит.

 

**Комментировать ID в коде**

Если в код вставлено значение идентификатора объекта из БД, стоит
написать комментарий, поясняющий какому объекту принадлежит
идентификатор.

 

### Комментарии в Админке

Нужно добавлять комментарии для объектов админки и их параметров, если
не очевидно, что они означают. Например, для переменных удаленных
действий или агентов.

 

**Комментирование блока catch**

Если при использовании конструкции try\...catch используется пустой
блок catch, то внутри него стоит указать, почему пойманная ошибка не
требует обработки.

*try {\
  callImportantFunction();\
} catch (error) {\
  // Nevermind\
}*

## 15. Архитектура

**Инверсия инструкции if**

Если есть возможность, используйте инверсию инструкции if и ранний
возврат.

function foo(a, b) {\
  if (a \> b) {\
    alert(\'bar\');\
  }\
}

*function foo() {\
  if (a \<= b) return;\
  alert(\'bar\');\
}*

 

**Универсальная выборка в настраиваемых отчетах**

Следует использовать универсальные выборки в настраиваемых отчетах, если
это возможно.

 

### Предотвращение копипаста

Следует выносить повторяющийся код в функции.

 

**Контроль и проверка результатов стандартных функций **

При использовании функций, которые могут возвращать undefined (которые
начинаются с Opt), необходимо обрабатывать такой случай. Например, перед
обращением к свойству объекта, который был получен через ArrayOptFind(),
необходимо проверить, что он не является undefined. Если мы
предполагаем, что этот объект всегда должен быть, то стоит использовать
функцию ArrayFind() - в случае отсутствия ошибка будет точнее указывать
на место с проблемой.

 

**Обработка \"магических чисел\"**

Следует вынесить магические числа в константы(различные id и подсчёт
секунд \* 24 \* 60 \* 60 \* (-1))

 

**Оборачивать возвращаемые из XQuery объекты в ArrayDirect (когда нужно
получить все элементы массива), если: **

a\) Планируется многократная обработка (особенно с прямым
индексированием) \"медленных\" массивов

b\) В цикле, осуществляющем проход по массиву, происходит выборочное
удаление его элементов.

c\) Требуется использование индексов

Однако стоит иметь в виду, что использование ArrayDirect или
ArraySelectAll в больших массивах (более 1000 строк) может привести к
переполеннию памяти (Out of memory)

### Использовать ArrayDirect, вместо ArraySelectAll

## 16. Аннотация типов

Для аннотации типов можно использовать
синтаксис [[JSDoc]{.underline}](https://jsdoc.app/).

 

**Локальные переменные**\
Для указания типа локальной переменной следует использовать тег @type .

*/\*\* \@type {string} \*/*

var userName;

*/\*\* \@type {number \| undefined} \*/*

var optInt;

*/\*\* \@type {number\[\]} \*/*

var managerIds;

*/\*\* \@type {{ foo: string, bar: boolean }} \*/*

var baz;

*/\*\* \@type {(a: string, b: number) =\> boolean} \*/*

var fn;

 

**Функции**\
Для описания параметров функции используйте тег @param . Для указания
возвращаемого значения - @returns .

*/\*\**

*\* \@param {Object} options*

*\* \@param {string} options.prop1*

*\* \@param {number} options.prop2*

*\* \@param {string} \[options.prop3\] - Опциональный параметр*

*\* \@returns {boolean}*

*\*/*

function func(options) {}

 

**Константы**

При определении константы используйте   @type{const} , чтобы указать,
что значение не будет изменяться.

var CONST_ID = */\*\* \@type{const} \*/* (123);

CONST_ID = 4; *// Ошибка*

 

### Сложные типы\
Чтобы описать сложный тип, используйте @typedef .

*/\*\**

*\* \@typedef {Object} SomeType*

*\* \@property {string} prop1*

*\* \@property {number} prop2*

*\*/*

*/\*\* \@type {SomeType} \*/*

var obj;

 

### Ошибки

Чтобы указать, что функция может выбрасывать ошибки, используйте
тег @throws .

*/\*\**

*\* \@param {number} projectId*

*\* \@param {\*} task*

*\* \@throws Выбросит ошибку, если проект не найден.*

*\*/*

function addTask(projectId, task) {

var project = getProjectById(projectId);

if (project == null) {

throw new Error(\'Проект не найден.\');

}

}

---

## 17. Отличия между SP-XML Script и JavaScript

**Важно понимать, что SP-XML Script и JavaScript – совершенно разные языки, хотя и похожие синтаксически, и имеющие некоторые схожие объекты и функции.**

### Типы данных

SP-XML Script по идеологии типов данных находится ближе к VBScript. Строка и дата – скалярные значения, а не объекты. Integer и real – разные типы. String и Date также поддерживаются как объекты, но это сделано для облегчения миграции кода с JavaScript.

В SP-XML Script строки являются бинарно-совместимыми. В них можно хранить как текст так и бинарные данные. Текст при этом хранится в кодировке, заданной в приложении (как правило utf-8). С одной стороны это дает удобство работы с бинарными данными, с другой – затрудняет посимвольную обработку строк. Например, функция StrLen() возвращает длину строки в байтах, а StrCharCount() – в символах. Другой пример: вызов StrLeftRange( str, 1 ) нельзя использовать для получения первого символа в строке, необходимо использовать StrLeftCharRange( str, 1 ).

Тип данных для просто даты и даты со временем не различаются. Дата может как содержать время так и не содержать его.

Дата и время в памяти хранятся в структурированном виде (отдельно год, месяц, день и т.д. в виде чисел), без привязки к глобальному времени. Часовой пояс также хранится отдельно. Этот принцип может быть нарушен, если дата сохранятся в базе данных с хранилищем на SQL, где будет осуществлено преобразование к местному типу данных и обратно.

Объект может использоваться как объект, либо может использоваться его скалярное значение, если объект его поддерживает. Например, поле в XML-документе является объектом, но имеет скалярное значение (string, integer и т.д.). При выполнении сравнения, арифметически операциях, преобразовании к строке, объект преобразуется к скалярному значению.

В SP-XML Script используется только строгое сравнение. Undefined, null, '', 0, false – это разные значения.

### Массивы

Помимо стандартного массива, аналогичного массиву в JavaScript, в SP-XML существует множество других видов массивов, обобщенно называемых абстрактными массивами (аналог enumerators в VBScript).

### Цикл for-in

Цикл for-in работает как в JavaScript только по стандартному объекту, обходя имена всех свойств.

Для абстрактных массивов он работает как цикл foreach в VBScript, обходя все значения.

### Функции

SP-XML Script исповедует концепцию библиотек с четким разделением на локальные переменные и глобальные переменные внутри библиотеки. Использование функций внутри кода, как в JavaScript, возможно, но не является рекомендуемой техникой.

### Ограничения языка

**В SP-XML Script НЕ поддерживаются:**

- `let` и `const` - этих ключевых слов нет в языке
- `var` в циклах - нельзя использовать `var` внутри циклов
- ES6+ возможности - язык похож на ES2 JavaScript, но не поддерживает современные возможности

**Общий синтаксис близок к JavaScript, но:**

- Часть функций работает по-другому
- Некоторые функции пишутся иначе
- Язык имеет ограничения, характерные для более старых версий JavaScript
- Рекомендуется использовать библиотеки вместо встроенных функций в коде
